"""
Core data structures and interfaces for the Local Signal Generation Framework.

This module defines the fundamental data types and interfaces used throughout
the signal generation system.
"""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional, Any, Union
import uuid


class SignalType(Enum):
    """Enumeration for different types of trading signals."""
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"


class SignalStrength(Enum):
    """Enumeration for signal strength levels."""
    WEAK = "WEAK"
    MODERATE = "MODERATE"
    STRONG = "STRONG"
    VERY_STRONG = "VERY_STRONG"


class MarketRegime(Enum):
    """Enumeration for different market regimes."""
    TRENDING_UP = "TRENDING_UP"
    TRENDING_DOWN = "TRENDING_DOWN"
    RANGING = "RANGING"
    VOLATILE = "VOLATILE"
    UNCERTAIN = "UNCERTAIN"


@dataclass
class Signal:
    """
    Represents a trading signal generated by the framework.

    Attributes:
        id: Unique identifier for the signal
        timestamp: When the signal was generated
        signal_type: Type of signal (BUY, SELL, HOLD)
        strength: Strength of the signal
        symbol: Trading symbol (e.g., 'AAPL', 'BTC/USD')
        price: Price at which signal was generated
        confidence: Confidence score (0.0 to 1.0)
        regime: Market regime when signal was generated
        indicators: Dictionary of indicator values that contributed to the signal
        metadata: Additional information about the signal
        source: Source component that generated the signal
        reasoning: Human-readable explanation of the signal
    """
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    timestamp: datetime = field(default_factory=datetime.now)
    signal_type: SignalType = SignalType.HOLD
    strength: SignalStrength = SignalStrength.WEAK
    symbol: str = ""
    price: float = 0.0
    confidence: float = 0.0
    regime: MarketRegime = MarketRegime.UNCERTAIN
    indicators: Dict[str, float] = field(default_factory=dict)
    metadata: Dict[str, Any] = field(default_factory=dict)
    source: str = ""
    reasoning: str = ""

    def __post_init__(self):
        """Validate signal data after initialization."""
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError("Confidence must be between 0.0 and 1.0")
        if self.price < 0:
            raise ValueError("Price must be non-negative")

    def to_dict(self) -> Dict[str, Any]:
        """Convert signal to dictionary representation."""
        return {
            "id": self.id,
            "timestamp": self.timestamp.isoformat(),
            "signal_type": self.signal_type.value,
            "strength": self.strength.value,
            "symbol": self.symbol,
            "price": self.price,
            "confidence": self.confidence,
            "regime": self.regime.value,
            "indicators": self.indicators,
            "metadata": self.metadata,
            "source": self.source,
            "reasoning": self.reasoning,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Signal":
        """Create signal from dictionary representation."""
        # Handle datetime conversion
        if isinstance(data.get("timestamp"), str):
            data["timestamp"] = datetime.fromisoformat(data["timestamp"])

        # Handle enum conversions
        if isinstance(data.get("signal_type"), str):
            data["signal_type"] = SignalType(data["signal_type"])
        if isinstance(data.get("strength"), str):
            data["strength"] = SignalStrength(data["strength"])
        if isinstance(data.get("regime"), str):
            data["regime"] = MarketRegime(data["regime"])

        return cls(**data)


@dataclass
class IndicatorScore:
    """
    Represents a scored indicator used in signal generation.

    Attributes:
        name: Name of the indicator (e.g., 'RSI', 'MACD')
        value: Raw indicator value
        score: Normalized score (-1.0 to 1.0)
        weight: Weight in signal calculation (0.0 to 1.0)
        signal_type: Signal type suggested by this indicator
        confidence: Confidence in this indicator's signal
    """
    name: str
    value: float
    score: float
    weight: float
    signal_type: SignalType
    confidence: float

    def __post_init__(self):
        """Validate indicator score data."""
        if not -1.0 <= self.score <= 1.0:
            raise ValueError("Score must be between -1.0 and 1.0")
        if not 0.0 <= self.weight <= 1.0:
            raise ValueError("Weight must be between 0.0 and 1.0")
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError("Confidence must be between 0.0 and 1.0")


@dataclass
class ConflictInfo:
    """
    Information about conflicts detected between signals.

    Attributes:
        conflict_type: Type of conflict (e.g., 'DIRECTION_CONFLICT', 'STRENGTH_CONFLICT')
        conflicting_signals: List of signal IDs that are in conflict
        severity: Severity of the conflict (LOW, MEDIUM, HIGH)
        description: Human-readable description of the conflict
        resolution_strategy: Suggested strategy to resolve the conflict
        timestamp: When the conflict was detected
    """
    conflict_type: str
    conflicting_signals: List[str]
    severity: str
    description: str
    resolution_strategy: str
    timestamp: datetime = field(default_factory=datetime.now)


@dataclass
class ValidationResult:
    """
    Result of signal validation.

    Attributes:
        is_valid: Whether the signal passed validation
        confidence: Overall confidence in the validation result
        issues: List of validation issues found
        recommendations: List of recommendations to improve the signal
        adjusted_confidence: Confidence after validation adjustment
    """
    is_valid: bool
    confidence: float
    issues: List[str] = field(default_factory=list)
    recommendations: List[str] = field(default_factory=list)
    adjusted_confidence: float = 0.0

    def __post_init__(self):
        """Initialize adjusted confidence if not set."""
        if self.adjusted_confidence == 0.0:
            self.adjusted_confidence = self.confidence


class SignalGenerator:
    """
    Main interface for the Local Signal Generation Framework.

    This class orchestrates all components to generate trading signals
    without relying on LLM calls.
    """

    def __init__(self, config: Dict[str, Any]):
        """Initialize the signal generator with configuration."""
        self.config = config
        self._components = {}

    def generate_signal(self, market_data: Dict[str, Any]) -> Signal:
        """
        Generate a trading signal based on market data.

        Args:
            market_data: Dictionary containing OHLCV data and other market information

        Returns:
            Signal: Generated trading signal
        """
        raise NotImplementedError("Subclasses must implement generate_signal method")

    def validate_signal(self, signal: Signal) -> ValidationResult:
        """
        Validate a generated signal.

        Args:
            signal: Signal to validate

        Returns:
            ValidationResult: Result of validation
        """
        raise NotImplementedError("Subclasses must implement validate_signal method")
